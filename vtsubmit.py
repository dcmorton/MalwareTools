#!/usr/bin/python
# Copyright (C) 2010 Michael Ligh
# 2012 Derek Morton - SQLite to MySQL conversion; additional tweaks
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# [NOTES] -----------------------------------------------------------
# 1) Tested on Linux (Ubuntu), Windows XP/7, and Mac OS X
# 2) You must NOT use this script if the respective vendors begin to
#    prohibit doing so in the future. You must consult all relevant 
#    acceptible usage policies.
#--------------------------------------------------------------------
import urllib, urllib2
import sys
import httplib
import os
import re
import time
import hashlib
import urlparse
import datetime
from optparse import OptionParser

from timeout import timeout

try:
    import MySQLdb
except ImportError:
    print "Cannot import MySQLdb, fix it"
    sys.exit()

# This should be stock with Python2.6 but not supplied in Python2.5
try:
    import simplejson
except ImportError:
    print 'You must install simplejson for VirusTotal, see http://www.undefined.org/python/'
    sys.exit()

#MySQL Connection Info
host = '' 
username = '' 
password = '' 
database = ''

# Put your VT Public API key below
VTAPIKEY=''

now = datetime.datetime.now()

## {{{ http://code.activestate.com/recipes/146306/ (r1)
import httplib, mimetypes

def post_multipart(host, selector, fields, files):
    """
    Post fields and files to an http host as multipart/form-data.
    fields is a sequence of (name, value) elements for regular form fields.
    files is a sequence of (name, filename, value) elements for data to be uploaded as files
    Return the server's response page.
    """
    content_type, body = encode_multipart_formdata(fields, files)
    h = httplib.HTTP(host)
    h.putrequest('POST', selector)
    h.putheader('content-type', content_type)
    h.putheader('content-length', str(len(body)))
    h.endheaders()
    h.send(body)
    errcode, errmsg, headers = h.getreply()
    return h.file.read()

def encode_multipart_formdata(fields, files):
    """
    fields is a sequence of (name, value) elements for regular form fields.
    files is a sequence of (name, filename, value) elements for data to be uploaded as files
    Return (content_type, body) ready for httplib.HTTP instance
    """
    BOUNDARY = '----------ThIs_Is_tHe_bouNdaRY_$'
    CRLF = '\r\n'
    L = []
    for (key, value) in fields:
        L.append('--' + BOUNDARY)
        L.append('Content-Disposition: form-data; name="%s"' % key)
        L.append('')
        L.append(value)
    for (key, filename, value) in files:
        L.append('--' + BOUNDARY)
        L.append('Content-Disposition: form-data; name="%s"; filename="%s"' % (key, filename))
        L.append('Content-Type: %s' % get_content_type(filename))
        L.append('')
        L.append(value)
    L.append('--' + BOUNDARY + '--')
    L.append('')
    body = CRLF.join(L)
    content_type = 'multipart/form-data; boundary=%s' % BOUNDARY
    return content_type, body

def get_content_type(filename):
    return mimetypes.guess_type(filename)[0] or 'application/octet-stream'
## end of http://code.activestate.com/recipes/146306/ }}}

class VirusTotal:
    def __init__(self, file):
        self.file = file

        f = open(self.file, "rb")
        self.content = f.read()
        f.close()

    def check(self, res):
        url = "https://www.virustotal.com/api/get_file_report.json"
        parameters = {"resource": res, 
                      "key": VTAPIKEY}
        data = urllib.urlencode(parameters)
        req = urllib2.Request(url, data)
        response = urllib2.urlopen(req)
        json = response.read()
        response_dict = simplejson.loads(json)
        try:
            return response_dict.get("report")[1]
        except:
            return {}

    def upload_file(self):
        host = "www.virustotal.com"
        selector = "http://www.virustotal.com/api/scan_file.json"
        fields = [("key", VTAPIKEY)]
        file_to_send = self.content
        files = [("file", os.path.basename(self.file), file_to_send)]
        return post_multipart(host, selector, fields, files)

    @timeout(60)
    def submit(self):
        resource = hashlib.md5(self.content).hexdigest()
        detects = self.check(resource)
        print 'Submitting file to VirusTotal'
        json = self.upload_file()
        if json.find("scan_id") != -1:
            offset = json.find("scan_id") + len("scan_id") + 4
            scan_id = json[offset:]
            scan_id = scan_id[:scan_id.find("\"")]
            print 'Trying scan_id ' + scan_id
            global vt_scan_id
            vt_scan_id = scan_id
            now2 = datetime.datetime.now()
            print 'Checking scan_id ' + scan_id + ' at ' + now2.strftime("%H:%M:%S")
            detects = self.check(scan_id)
            if len(detects) > 0:
                return detects
            else:
                print "Sample Submitted. Check back later for results"
                sys.exit()
        return {}

def savetodb(filename, detects, vt_scan_id, force):
    
    if len(detects) == 0:
        print "Nothing to add, submission failed."
        return

    conn = MySQLdb.connect(host=host, user=username, passwd=password, db=database)
    curs = conn.cursor()

    md5 = hashlib.md5(open(filename, 'rb').read()).hexdigest()

    try:
        curs.execute("INSERT INTO samples VALUES (NULL,%s,%s,NOW())", (md5,vt_scan_id))
    except MySQLdb.Error, e:
        print "Error inserting record: %s" % e
        print "Error %d: %s" % (e.args[0], e.args[1])
        return

    sid = curs.lastrowid 
    print "Added sample to database with ID %d" % sid
    for key,val in detects.items():
        curs.execute("INSERT INTO detects VALUES (NULL,%s,%s,%s)", (sid, key, val))

    curs.close()
    conn.commit()
    conn.close()

def initdb():

    conn = MySQLdb.connect(host=host, user=username, passwd=password, db=database)
    curs = conn.cursor()

    curs.execute("""
        CREATE TABLE samples (
            id   INTEGER PRIMARY KEY AUTO_INCREMENT,
            md5  TEXT,
            scan_id  TEXT,
            time  DATETIME
        );

        CREATE TABLE detects (
            id       INTEGER PRIMARY KEY AUTO_INCREMENT,
            sid      INTEGER,
            vendor   TEXT,
            name     TEXT
        );
        """)
    
    curs.close()
    conn.commit()
    conn.close()

def checkdb(filename, force):

    conn = MySQLdb.connect(host=host, user=username, passwd=password, db=database)
    curs = conn.cursor()

    md5 = hashlib.md5(open(filename, 'rb').read()).hexdigest()
    
    curs.execute("SELECT id FROM samples WHERE md5=%s", (md5,))
    ids = curs.fetchall()

    if len(ids):
        if not force:
            ids = ["%d" % id[0] for id in ids]
            print "The sample exists in the database with ID %s" % (','.join(ids))
            print "Use the -o or --overwrite option to force"
            print
            sys.exit()
        else:
            curs.execute("DELETE FROM samples WHERE md5=%s", (md5,))
            return

    curs.close()
    conn.commit()
    conn.close()


def main():
    parser = OptionParser()
    parser.add_option("-i", "--init", action="store_true", 
                       dest="init", default=False, help="initialize database")
    parser.add_option("-o", "--overwrite", action="store_true",
                       dest="force", default=False,
                      help="overwrite existing DB entry")
    parser.add_option("-f", "--file", action="store", dest="filename",
                      type="string", help="upload FILENAME")
    parser.add_option("-v", "--virustotal", action="store_true",
                       dest="virustotal",
                      help="use VirusTotal")

    (opts, args) = parser.parse_args()
    
    if opts.init:
        initdb()
        sys.exit()

    if opts.filename == None:
        parser.print_help()
        parser.error("You must supply a filename!")
    if not opts.virustotal:
        parser.print_help()
        parser.error("You must supply an action!")

    if not os.path.isfile(opts.filename):
        parser.error("%s does not exist" % opts.filename)

    if opts.virustotal:
        print "Using VirusTotal..."
        print "Analyzing " + opts.filename
        print "Submitted at " + now.strftime("%H:%M:%S %m-%d-%Y")
        if not sys.modules.has_key("simplejson"):
            print 'You must install simplejson'
            sys.exit()
        checkdb(opts.filename, opts.force)
        vt = VirusTotal(opts.filename)
        detects = vt.submit()
        savetodb(opts.filename, detects, vt_scan_id, opts.force)

if __name__ == '__main__':
    main()
